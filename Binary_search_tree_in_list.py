gAAAAABfUi-D5ANfW0dfsdReOW9wxe8_vUoflzxzDE0aLyJnoJ9a5zzLh0yY1W4PjIFLkU9bTQEG6eLwaRcp7zB7yZrUfynFnP4CftXujvxfcbPNOH4EF0iKcJB450ravqp8-C0keWXQ1I7R_QRxc-hvGmS0bWNtheOgsm33oEs5bcj8yofihE2JRztAVe4tb_DJEsfZbsMCkgEo1bMfQOyoF7sbgWvy725eljqB5EbpKZyDQzdLHWnQWvjHvryk-5P9OHvnpCa4pS5X9ixJ9bJuM29wvd3bW_wvk1AixdkUgmKESjzfS7-TrwLbKHqePlaSzg9-j7sK_j9VynjylJTuSNi2UOUo9Oxbr1GWHC-rmeR3fD4WqlMduoqFdqKQ6UQMAix3JwI5WwxVh9GpTHeMw358LwsoyE74i6ZFu2HzkaS8htA_SqseVhY-6jh6Xyxr94L1wfcRR2kdMcmy0rJSPfkTcCAFTQqWMRsnQ0qN-8cGprDg94H0olLoVHE-feVczgE02JxjNPFNvSXCumckR0K_n3ACOBD3fQhgzfvdXdWqXx20f7iNNZ449GdYzvxuvt7CZ-JM3JUcfI4iHFar3hB8FTGbuxJANcO5xe4UBrfW8BIOEgfIzLTiWo_osKumKSM2mOYF8TZY_LnP3luMuyclzX89mE1nqCqqiAuz9gUbobSpoVI5b6ByPgETyWpzhN1DlVZv3GId313_xBupCjpqK1Jphn2HSH8m9AW9QIlH_tALGO_U1DJbUyzrbO02pxylpz5pfI5BSSe2fptBsJccOoeu71Utr5f0fjScGfHX08qSSvY2JLl_YiAKv9EX0xx7L5vXeuHDmGtmva-F-dp38zqrlLeh6PGA0rYQXp3-OvKf8nw1Le2V_0UXd8LTb4I0QO89l77c5dEQ4yq06rNtd2MGqk3KPlNlla4o_HS3Nv9HSjRLidKJ0aVq0yT3BFSPIKlzJUrYrqTLNvG_Gour3pbvldkQBrBD5CUYNqCj77M5slu75LSsCNJ_JL_RIH0cP7ECBKp3LkLREa3_RG9_kRJOfEiKrxGn1cZisniFy0CYNt_E2Pt9r52LJosodWvdqRM3hXONLGZDebhpdRSARfp071C4i6hiUXFl4j2TYJ2SM-dUgUzNojL6vCLDvmpC3Q_nSHIT6sraqXyiL-LrkAJltekJNM9O68KQ9CpF9C5WW7AFBUU0MA21IPAY1NnHYZwWLdxkiE2YDc9GMlLToFW8bR-xD3aOHLC_QItZn72oXPSTm6OfMSI828vrMgmpV4aDhX67LRCLEGoePqafpd42C19krryV8qYWVCuzxD9lu_jZZVaZDQLP04xrGevc995e0DiGIfqCHGgsJ1tL5t7KTyEo281Ty-4UtgwgBMRb_5cF0yAV52diyfzdXP71e-KS9m-X3I6VuTexUDEbJGvr0qXTpD9XFGeq2Cy-XBfJuQi79QzGlFOTorjY59ULHG30kRVHb5iW5q5ZYRNcGlLVk9oxODgZRg7z4VocdB19T_ut_XMqu0wJWGB7BhAvC4rmtObKOAa0WLMQ9fGXzmSYlEeczipiOK9LNLGIAwA7f_u8gLAM6gU_FZ4kao6Wh3Aml8-58fsSnQ7wDOLU1GQ_HJTljz3T89T7cNAFhHpXNVC7ldFG_ML64KeH-ZsiVRnWgO7-pP20vDe8ZI87lCy_tri1rJzaO6yNaBYQ46v5VYg5gaJ3EMSIFuWgj9J1XS3JZV7Vk8rW55Z08pKH7GMOd_w0HJi3FEQ9D38oQcOKdWi7M0ir1q4zE5sMt7qCEzrG1ch7oEb2sfTrHlh5iiSDZMhkWoCIqZLfVvSVicbfHD5Q2wze3zeq0DkGiQXHtd-UEbOjK8jKIs2pmAND9Mg9WAnbAod1tC-v_4093Mvnkq0F_W4UNpcSC3-weRnuvN0NZJhxGkaoPfXjVt7e6Cg4b9An6eXYL43UcCWTDgnXyW3pqMJtSKk5BjJzmPeqCMsGcF5FYiJhO1aBtJrOlrnGQNAk7m6NSplUTKaaM3pOSonFTaskJYiAli8bZHz-3HLhlqZMMfH6ec_rUPb-JKmeUAcPDZyZmONs4VDUy_k0PRe8q-5odgObDi5kqVziy7WUNIZ188Gfa-kgVylfvE6xTeK-KjXq1UEYY0UjIF2pkcb6UWTY7gl2a24Cy1wIQGgrUzjmwlMHgbsGtN65CcBojDbUzrJyhPm8TDFwG5MM_9AKr_iVMHz5C-nlbnykqWhGz9rsnnQAua9K39DFpOuHlKVASmB73Tm8Hv5dSBJwhRr4lZZdG5MeiOaew4fWQHUjxgiOJ_pV29Zai3KiC0-EkpX-PXkJV8Ct7bV0AZZfO2j7bv5LChhrdZBvHoajMKr_LgXBhOU8yrhCvMMiT3ZkH7vcMVij-vpKbm2HHbajCE7BYSUshVnOI6u1n8j4HzeSF-TJIXROqUSJMhxJxcZFHi4HdzeurOBdzpyRyhGBbxT9gFUYkQ-inS_FrU3AlpuzTo8mYP8t7AnBse-Ssn9-VAts6BvLnxizxzJ7Ta8XbXwKm63HEyenqeXDj8you1tjzV557Ah4JD4surQNAqWIRsmrGrixOSR5ltndF-ytfZ3iKQgD8meTq0zC6Oj3cdBkxyDpNmtYc-xM0m1KxbXfNkoC6gMduuPYoIzjOmxWcjSrR2rSJKGWG6F4w2qmud7b6uFu4mtRCLbDdI0_s4qDNOXWHSPRX2-MhqNDGHVMBjCHRi3fCcedUygJrpqSf-lmSwCi-_XidgW62FMmf1hfx-2T84lDdZQMb-FDni9BBOaoIw2ESnu9WfwpHGYLdxlaLq59QoYFCkDby0XSQ1a7hyG9Mmu78_UJ9nf3cUEiATXFfoTfRPaG9eovm_FaF5iteQt_x_u7dYPaRkhfUdTt71L4x-vmQBITIO-fK9hKcPALBVY5V2jw58YTyvIQOd6QYz5qDLPnw_Cz7xFbHU04DMphXfuenqEN-WZS5rt97rgSCjjZX2EZmaNd4s_qvk_xdT5YmqgM-xVJARCicx7Pjv2ovxfYOuzOzR6dxC3V1b9rRutY_NUFh-BsV3hrRQ4SdNabE0CU6p214HqOgLbV54sFtRKTDDywYRCiJsax-U563ILof48jG2sFUSDCiKuyhDbNA2Bv-AIHBfw6brDBVI3lFRZ1cS93jjcKY9dWGBoB3drGNJISdN75LIYrRRQLlZ6Ca0TUsCRyADbOVj18zRFCgbuiS7s55Ui4LTEnaUwJievbNeuK7qJdclg6R7UpU1y9vputCr3UPQPTFu4I9FYvVZ8kiMxbb-sWRCZoEAXbK70MXS3yU3x1iRSQGQNriRNeRyjjBdwnPBcJqmY1L99yYU3O5tuz7u6s3XUzYTuZlRzoyIMzrz-iQtDr_SN3S92FBvx_8JDtwrS49IQalot3Ej2IC40N00-3Fva3sB24F87eKlkeG-Bv8D3aDnTtp666ZHV0YvtWEz7VzT97wHraBBFyrwNf9CEbxHOozDiv9ULXVDsnYZaj0obXlMTBuK1BFF7xPNusqIetpLzcSNT70TBZwGVfFdc4ztUOUbB3Bs4VnpDNvM16aMZvAyQ-0I0i8NdG3dRCUouz3RCs_5OIJ1SSRSBr479pR9gx65bo3wxBV-Jo4TiIJBKH5IZsGwTY-otU_S9FqLcmHDa95MLUHOXuHNDPNZBOR16QhFFz5kGyVjUkGlk3dTlrpOxEhRVUcN7hxQwNV3rExps3YPWcF80woYztENJYpMfIKz5tMJ3c2fPsXBiV3tQRAr1V2WCFRVXYhStsXqT3P28HBy5UxRlgk5CZ5OAvlerSoYCrRxxYmvrY8SVAI8lu3tSUUT-ihHO-0iTKWU5kkHWaRmTIY7BdSpcZWJzc7OHrzi-Oqv2tiPrq-tEaEZScMs8U0lUcCmZe5o_9BAMx68NjCXsOA8jvDfAYYDb8QEX8mBvSxpbWePkzb36pr2U2oJDhbdA_uMAbjcEDNA1EFYYmoPj1FSsmiGJjh_T7E59k3FKr-Tu6WSLEtcNZCBPHmPZiQjfxRQphBbPahw9eB0XR_m1Z8_4cjnyc33JisDBpTiFqPzkoJCFHV9bpgQ2yzQkKd8CQuYxi7zf8qRM_emqqsJhPuZ20H_e3LqpJbzl0Cm-z5y1xCHZ_VakLxHRZc3lQPIWR5picurntKVzo2TnjHbnfasQEMkVpYF3VV6JMqScX6tzZUgSpUwu5nDDlDxy2WMvE7LVQu3dUo-e10TkyNA6_sOjKzN0akFkt-H4QwZTK5VVCg87Bxh3wXa_wBQO4BSPWGf9sxn4TC5QHnF8yZg==

class aBST:

    def __init__(self, depth):

        tree_size = sum(2 ** i for i in range(depth + 1))
        self.Tree = [None] * tree_size

    def FindKeyIndex(self, key):

        finder = 0
        left_child = 2 * finder + 1
        right_child = 2 * finder + 2
        while finder < len(self.Tree):
            if self.Tree[finder] is None:
                return -finder
            elif key < self.Tree[finder]:
                finder = left_child
            elif key > self.Tree[finder]:
                finder = right_child
            else:
                return finder
            left_child = 2 * finder + 1
            right_child = 2 * finder + 2
        return None

    def AddKey(self, key):

        index = self.FindKeyIndex(key)
        if index is None:
            return -1
        else:
            if index > 0:
                return index
            else:
                self.Tree[-index] = key
                return -index

    def DeleteKey(self, key):

        index = self.FindKeyIndex(key)
        if index > -1:
            accum = []
            accum.append(index)
            while accum:
                index = accum.pop(0)
                self.Tree[index] = None
                left_child = 2 * index + 1
                right_child = 2 * index + 2
                if left_child < len(self.Tree):
                    accum.append(left_child)
                if right_child < len(self.Tree):
                    accum.append(right_child)
            return True
        else:
            return False

import unittest

class Test_aBST(unittest.TestCase):

    def setUp(self):
        
        test.Tree = [8, 4, 12, 2, 6, 10, 14, 1, 3, 5, 7, 9, 11, 13, 15]

    def test_FindKeyIndex(self):
        
        for key in test.Tree:
            self.assertEqual(test.FindKeyIndex(key), test.Tree.index(key))
        for i in range(2 * len(test.Tree), 3 * len(test.Tree)):
            self.assertEqual(test.FindKeyIndex(i), None)
        Tree_2 = test.Tree
        test.__init__(3)
        for key in Tree_2:
            index = test.FindKeyIndex(key)
            self.assertEqual(-index, Tree_2.index(key))
            test.Tree[-index] = key

    def test_AddKey(self):
        
        Tree_2 = test.Tree
        test.__init__(3)
        for key in Tree_2:
            test.AddKey(key)
        self.assertEqual(test.Tree, Tree_2)
        for i in range(len(Tree_2)):
            self.assertEqual(test.AddKey(Tree_2[i]), i)
        for i in range(2 * len(test.Tree), 3 * len(test.Tree)):
            self.assertEqual(test.AddKey(i), -1)

    def test_DeleteKey(self):
        
        test.DeleteKey(8)
        self.assertEqual(test.Tree, [None] * len(test.Tree))
        test.Tree = [8, 4, 12, 2, 6, 10, 14, 1, 3, 5, 7, 9, 11, 13, 15]
        test.DeleteKey(6)
        self.assertEqual(test.Tree, [8, 4, 12, 2, None, 10, 14, 1, 3, None, None, 9, 11, 13, 15])
        test.Tree = [8, 4, 12, 2, 6, 10, 14, 1, 3, 5, 7, 9, 11, 13, 15]
        test.DeleteKey(11)
        self.assertEqual(test.Tree, [8, 4, 12, 2, 6, 10, 14, 1, 3, 5, 7, 9, None, 13, 15])

if __name__ == '__main__':
    
    test = aBST(3)
    unittest.main(verbosity=2)
